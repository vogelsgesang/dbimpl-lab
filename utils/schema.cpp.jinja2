#ifndef H_Schema
#define H_Schema
#include <iterator>
#include <vector>
#include <tuple>
#include "Types.hpp"
//-----------------------------------------------------------------------------
{% for table in schema -%}
struct {{table.name}}_t {
  typedef std::tuple<
    {%- for column in table.columns %}
    std::vector<{{column.type | translate_type}}>{{"," if not loop.last else ""}} //{{column.name}}
    {%- endfor %}
  > storage_type;

  auto size() {return std::get<0>(data).size();}

  {% for column in table.columns -%}
  auto& {{column.name}}() { return std::get<{{loop.index0}}>(data); }
  const auto& {{column.name}}() const { return std::get<{{loop.index0}}>(data); }
  {% endfor %}

  class dereferenced_iterator {
    public:
      dereferenced_iterator(storage_type &data, size_t offset) : data(data), offset(offset) {}

      {% for column in table.columns -%}
      auto& {{column.name}}() { return std::get<{{loop.index0}}>(data)[offset]; }
      const auto& {{column.name}}() const { return std::get<{{loop.index0}}>(data)[offset]; }
      {% endfor %}
    private:
      storage_type &data;
      size_t offset;
  };

  class iterator {
    public:
      typedef std::input_iterator_tag iterator_category; // actually not an input iterator. But this is the best fitting category
      typedef dereferenced_iterator reference;
      typedef dereferenced_iterator* pointer;
      typedef dereferenced_iterator value_type;
      typedef size_t difference_type;

      iterator(storage_type &data, size_t offset) : data(data), offset(offset) {}

      iterator& operator++() {++offset; return *this;}
      iterator operator++(int) {auto copy = *this; offset++; return copy;}
      iterator& operator--() {--offset; return *this;}
      iterator operator--(int) {auto copy = *this; offset--; return copy;}

      bool operator==(const iterator& rhs) const {return &data == &rhs.data && offset == rhs.offset;}
      bool operator!=(const iterator& rhs) const {return !(*this == rhs);}

      size_t operator-(const iterator& rhs) const {return offset - rhs.offset;}

      auto operator*() { return dereferenced_iterator{data, offset}; }

    private:
      storage_type &data;
      size_t offset;
  };

  auto begin() {return iterator{data, 0};}
  auto end() {return iterator{data, size()};}

  storage_type data;
};
//-----------------------------------------------------------------------------
{% endfor -%}
{% for table in schema -%}
extern {{table.name}}_t {{table.name}};
{% endfor -%}
//-----------------------------------------------------------------------------
#endif
